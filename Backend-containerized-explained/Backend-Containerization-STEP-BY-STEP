THIS IS HOW TO CONTAINERIZE APPLICATION STEP BY STEP


**************************************************
*****************  **STEP 1**  *******************
**************************************************

rename application.properties to application.yml or yaml (both are correct)- file is found
in src/main/resources
 (now you can use yaml text formatting)
 (application.properties is the file where we used to spring jpa properties
 // spring.jpa.hibernate.ddl-auto=update
  //  spring.datasource.url=jdbc:mysql://localhost:3306/mydatabase
   // spring.datasource.username=myuser ....


now the file because its renamed to yml uses following formatting :
..............................................................
.                                                            .
.spring:                                                     .
. datasource:                                                .
.    url: ${SPRING_DATASOURCE_URL}                           .
.    username: ${SPRING_DATASOURCE_USERNAME}                 .
.    password: ${SPRING_DATASOURCE_PASSWORD}                 .
.                                                            .
.  jpa:                                                      .
.    hibernate:                                              .
.      ddl-auto: ${SPRING_JPA_HIBERNATE_DDL_AUTO}            .
.    show-sql: ${SPRING_JPA_SHOW_SQL}                        .
.    properties:                                             .
.      hibernate:                                            .
.        dialect: org.hibernate.dialect.PostgreSQLDialect    .
.                                                            .
..............................................................

We are using environment variable formatting here example >>>>  ${SPRING_DATASOURCE_URL} <<<< because this way
docker.compose.yml will to draw data from application.yaml (old application.properties)so make sure you keep ${} format


**************************************************
*****************  **STEP 2**  *******************
**************************************************
create Dockerfile



Open this and Dockerfile side by side for better understanding

#......................................................
#....Step 1: (BUILDER STAGE) Builds the application....
#......................................................
# uses gradel image that has jdk21 and compile it with gradel
FROM gradle:jdk21-alpine AS builder

# Sets app to current workign directory (its where  u place DOCKERFILE)
WORKDIR /app
# and all commands below WORKDIR /app will be run directly

COPY . .
#copies all files from local project directory to the "/app" directory in the CONTAINER
# because build process needs all project files

RUN gradle bootJar
# runs gradle command to build executable JAR file of springboot app
# simply compiles your application into JAR file

#......................................................
#....Step 2: (RUNTIME STAGE) Create a runtime image....
#......................................................

RUN ls -la /app/build/libs
# this lists the files in the /app/build/libs directory.
# This is debugging step to verify JAR was created successfully

FROM amazoncorretto:21
# uses Amazon Corretto image that includes JDK 21
# I use this because its lightweight JDK image suitable for running apps

WORKDIR /app
#yes we need this second time because this time its for Runtime stage

COPY --from=builder /app/build/libs/*.jar app.jar
# Copy the build jar = copies JAR file created in 1st Builders stage step1  to the
# current working directory = this is compiled application that will runnnn

ENTRYPOINT ["java", "-jar", "app.jar"]
# sets the entry point >> Sets the command to run the application using java -jar app.jar
# why ? this step starts your springboot app when container is run



# DESCRIPTION IN DETAILS

# First Stage: Build the Application
  #
  #You use a Docker image that already has Gradle and JDK 21 installed.
  #You copy all your project files into this Docker container.
  #You run the Gradle build command to create the JAR file.
  #You check to make sure the JAR file is created successfully.

#Second Stage: Create a Runtime Environment
  #
  #You switch to a smaller Docker image that only includes the JDK 21, which
  # is needed to run Java applications.
  #You copy the JAR file from the build stage into this new image.
  #You specify that when this container starts, it should run the Java
  # application using the JAR file.


 **************************************************
 *****************  **STEP 3**  *******************
 **************************************************

 DOCKER-COMPOSE.YML explainded  << again open this guide side by side with docker-compose.yml

 My-Notes/
 ├── .idea/
 ├── Backend-containerized-explained/
 │   ├── Backend-yolo-API/
 │   │   ├── .gradle/
 │   │   ├── gradle/
 │   │   ├── src/
 │   │   │   └── main/
 │   │   │       ├── java/
 │   │   │       │   └── backendyoloapi/
 │   │   │       │       └── BackendYoloApiApplication.java
 │   │   │       └── resources/
 │   │   │           └── application.yml  <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< STEP 1
 │   │   ├── build.gradle
 │   │   ├── gradlew
 │   │   ├── gradlew.bat
 │   │   ├── settings.gradle
 │   │   └── Dockerfile <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< STEP 2
 │   ├── Frontend-is-to-be-here/
 │   └── Backend-Containerization-STEP-BY-STEP/
 ├── docker-compose.yml <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< STEP 3 HERE WE ARE
 └── README.md


  we create dockerfile and rename it to docker-compose.yml <<< this way we can use yml formatting again


  version: '3.9'

  services:
    yoloapp:
      build:
        context: Backend-yolo-API
      ports:
        - "9099:8080"
      environment:
        SPRING_DATASOURCE_URL: jdbc:postgresql://yolodb:5435/yolodb
        SPRING_DATASOURCE_USERNAME: yolouser
        SPRING_DATASOURCE_PASSWORD: yolopassword
        SPRING_JPA_HIBERNATE_DDL_AUTO: none
        SPRING_JPA_SHOW_SQL: "true"
        SPRING_JPA_PROPERTIES_HIBERNATE_DIALECT: org.hibernate.dialect.PostgreSQLDialect
      depends_on:
        - yolodb

    yolodb:
      image: postgres:13-alpine
      environment:
        POSTGRES_DB: yolodb
        POSTGRES_USER: yolouser
        POSTGRES_PASSWORD: yolopassword
      ports:
        - "5435:5432"
      volumes:
        - yolodb_data:/var/lib/postgresql/data

  volumes:
    yolodb_data:



This docker.compose.yml file defines a multi-container application with two services:

Summary
Version 3.9: Uses the Docker Compose file format version 3.9.
Services:
yoloapp:
Build Context: Specifies the directory Backend-yolo-API for the Docker build context.
Ports: Maps port 9099 on the host to port 8080 in the container.
Environment Variables: Sets up Spring Boot environment variables for database connectivity and JPA configuration.
depends_on: Ensures that the yolodb service is started before yoloapp.
yolodb:
Image: Uses the postgres:13-alpine image for the PostgreSQL database.
Environment Variables: Configures the PostgreSQL database, user, and password.
Ports: Maps port 5435 on the host to port 5432 in the container.
Volumes: Uses the named volume yolodb_data to persist PostgreSQL data.
Volumes:
yolodb_data: Defines a named volume to persist PostgreSQL data.