THIS IS HOW TO CONTAINERIZE APPLICATION STEP BY STEP


**************************************************
*****************  **STEP 1**  *******************
**************************************************

rename application.properties to application.yml or yaml (both are correct)- file is found
in src/main/resources
 (now you can use yaml text formatting)
 (application.properties is the file where we used to spring jpa properties
 // spring.jpa.hibernate.ddl-auto=update
  //  spring.datasource.url=jdbc:mysql://localhost:3306/mydatabase
   // spring.datasource.username=myuser ....


now the file because its renamed to yml uses following formatting :
..............................................................
.                                                            .
.spring:                                                     .
. datasource:                                                .
.    url: ${SPRING_DATASOURCE_URL}                           .
.    username: ${SPRING_DATASOURCE_USERNAME}                 .
.    password: ${SPRING_DATASOURCE_PASSWORD}                 .
.                                                            .
.  jpa:                                                      .
.    hibernate:                                              .
.      ddl-auto: ${SPRING_JPA_HIBERNATE_DDL_AUTO}            .
.    show-sql: ${SPRING_JPA_SHOW_SQL}                        .
.    properties:                                             .
.      hibernate:                                            .
.        dialect: org.hibernate.dialect.PostgreSQLDialect    .
.                                                            .
..............................................................

We are using environment variable formatting here example >>>>  ${SPRING_DATASOURCE_URL} <<<<
so make sure you keep ${} format. Why? because we define everything in step3 (docker-compose.yml)


**************************************************
*****************  **STEP 2**  *******************
**************************************************
create Dockerfile



Open this and Dockerfile side by side for better understanding

#......................................................
#....Step 1: (BUILDER STAGE) Builds the application....
#......................................................
# uses gradel image that has jdk21 and compile it with gradel
FROM gradle:jdk21-alpine AS builder

# Sets app to current workign directory (its where  u place DOCKERFILE)
WORKDIR /app
# and all commands below WORKDIR /app will be run directly

COPY . .
#copies all files from local project directory to the "/app" directory in the CONTAINER
# because build process needs all project files

RUN gradle bootJar
# runs gradle command to build executable JAR file of springboot app
# simply compiles your application into JAR file

#......................................................
#....Step 2: (RUNTIME STAGE) Create a runtime image....
#......................................................

RUN ls -la /app/build/libs
# this lists the files in the /app/build/libs directory.
# This is debugging step to verify JAR was created successfully

FROM amazoncorretto:21
# uses Amazon Corretto image that includes JDK 21
# I use this because its lightweight JDK image suitable for running apps

WORKDIR /app
#yes we need this second time because this time its for Runtime stage

COPY --from=builder /app/build/libs/*.jar app.jar
# Copy the build jar = copies JAR file created in 1st Builders stage step1  to the
# current working directory = this is compiled application that will runnnn

ENTRYPOINT ["java", "-jar", "app.jar"]
# sets the entry point >> Sets the command to run the application using java -jar app.jar
# why ? this step starts your springboot app when container is run



# DESCRIPTION IN DETAILS

# First Stage: Build the Application
  #
  #You use a Docker image that already has Gradle and JDK 21 installed.
  #You copy all your project files into this Docker container.
  #You run the Gradle build command to create the JAR file.
  #You check to make sure the JAR file is created successfully.

#Second Stage: Create a Runtime Environment
  #
  #You switch to a smaller Docker image that only includes the JDK 21, which
  # is needed to run Java applications.
  #You copy the JAR file from the build stage into this new image.
  #You specify that when this container starts, it should run the Java
  # application using the JAR file.


 **************************************************
 *****************  **STEP 3**  *******************
 **************************************************

 DOCKER-COMPOSE.YML explainded  << again open this guide side by side with docker-compose.yml

 My-Notes/
 ├── .idea/
 ├── Backend-containerized-explained/
 │   ├── Backend-yolo-API/
 │   │   ├── .gradle/
 │   │   ├── gradle/
 │   │   ├── src/
 │   │   │   └── main/
 │   │   │       ├── java/
 │   │   │       │   └── backendyoloapi/
 │   │   │       │       └── BackendYoloApiApplication.java
 │   │   │       └── resources/
 │   │   │           └── application.yml  <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< STEP 1
 │   │   ├── build.gradle
 │   │   ├── gradlew
 │   │   ├── gradlew.bat
 │   │   ├── settings.gradle
 │   │   └── Dockerfile <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< STEP 2
 │   ├── Frontend-is-to-be-here/
 │   └── Backend-Containerization-STEP-BY-STEP/
 ├── docker-compose.yml <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< STEP 3 HERE WE ARE
 └── README.md


  we create dockerfile and rename it to docker-compose.yml <<< this way we can use yml formatting again


 version: '3.9'
 services:
   yoloapp:
     build:
       context: ./Backend-yolo-API     <<<<<<<<< check project structure this finds path to backend
       dockerfile: ./Backend-yolo-API/Dockerfile  OR dockerfile: Dockerfile << this finds dockerfile if you mess up here = db starts but app wont
     ports:
       - "9099:8080"
     environment:
       SPRING_DATASOURCE_URL: jdbc:postgresql://yolodb:5435/yolodb
       SPRING_DATASOURCE_USERNAME: yolouser
       SPRING_DATASOURCE_PASSWORD: yolopassword
       SPRING_JPA_HIBERNATE_DDL_AUTO: none
       SPRING_JPA_SHOW_SQL: "true"
       SPRING_JPA_PROPERTIES_HIBERNATE_DIALECT: org.hibernate.dialect.PostgreSQLDialect
     depends_on:
       - yolodb

   yolodb:
     image: postgres:13-alpine
     environment:
       POSTGRES_DB: yolodb
       POSTGRES_USER: yolouser
       POSTGRES_PASSWORD: yolopassword
     ports:
       - "5435:5432"
     volumes:
       - yolodb_data:/var/lib/postgresql/data

 volumes:
   yolodb_data:



This docker.compose.yml file defines a multi-container application with two services:

Summary
Version 3.9: Uses the Docker Compose file format version 3.9.
Services:
yoloapp:
Build Context: Specifies the directory Backend-yolo-API for the Docker build context.
Ports: Maps port 9099 on the host to port 8080 in the container.
Environment Variables: Sets up Spring Boot environment variables for database connectivity and JPA configuration.
depends_on: Ensures that the yolodb service is started before yoloapp.
yolodb:
Image: Uses the postgres:13-alpine image for the PostgreSQL database.
Environment Variables: Configures the PostgreSQL database, user, and password.
Ports: Maps port 5435 on the host to port 5432 in the container.
Volumes: Uses the named volume yolodb_data to persist PostgreSQL data.
Volumes:
yolodb_data: Defines a named volume to persist PostgreSQL data.



 **************************************************
 *****************  **STEP 4**  *******************
 **************************************************


Terminal commands / how to operate it

(use this if you want to load up new changes made)

docker-compose up --build:
This command will forcefully rebuild the images for the services defined in your docker-compose.yml file before starting the containers.
It is useful when you have made changes to the Dockerfile or dependencies that the images are based on and want to ensure that the latest changes are included.


docker-compose up:
This command will start the services defined in your docker-compose.yml file using the existing images.
If the images are not present locally, Docker will pull them from the registry.
It does not rebuild the images unless it detects changes in the Dockerfile or the image dependencies.
Use docker-compose up --build when you want to ensure that any changes to your Dockerfile or dependencies are included
 in the build, and docker-compose up for starting the services without rebuilding the images.


this is guide from mark

# Docker compose

## Run the project

```bash
docker-compose up
```

## Stop the project

```bash
docker-compose down
```

### Run the database only

```bash
docker-compose up db # or docker-compose up -d db
```


### Run the backend only intelliJ

Use the following configuration in IntelliJ; setup configuration with following environment variables:

```bash
SPRING_DATASOURCE_URL=jdbc:postgresql://localhost:5432/mydatabase
SPRING_DATASOURCE_USERNAME=myuser
SPRING_DATASOURCE_PASSWORD=mypassword
SPRING_JPA_HIBERNATE_DDL_AUTO=none
SPRING_JPA_SHOW_SQL=true
```

after that run the configuration. :rocket:

